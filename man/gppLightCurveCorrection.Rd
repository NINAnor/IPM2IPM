% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gppLightCurveCorrection.R
\name{gppLightCurveCorrection}
\alias{gppLightCurveCorrection}
\title{Run Hierarchical PAR Calibration Model}
\usage{
gppLightCurveCorrection(
  inputData,
  lightValues,
  yAssymModel,
  xAssymModel,
  multiplierModel = 1,
  indirectComponents = NULL,
  regCoeffs = "none",
  lightStandards = c(),
  mcmcParams = list()
)
}
\arguments{
\item{inputData}{A \code{data.frame} containing the data to be used in the calibration model}

\item{lightValues}{A character scalar of the column name in \code{data} that represents
the values of PAR.  Alternatively \code{lightValues} can be a numeric vector with length
equal to the number of rows in \code{data} which gives the PAR values directly}

\item{yAssymModel}{A \code{formula} object giving the relationship between the y-assymptote
and a set of covariates.  The left-hand term of the formula should be the term representing
GPP.  If the left-hand term is missing then GPP is searched for in the other model
formulas \code{xAssymModel} and \code{multiplierModel}.  This parameter can also a be a
numeric \code{vector}, in which case the model will be replaced by an 'offset' constant with
values given in the vector}

\item{xAssymModel}{A \code{formula} object giving the relationship between the x-assymptote
and a set of covariates.  The left-hand term of the formula should be the term representing
GPP.  If the left-hand term is missing then GPP is searched for in the other model
formula \code{multiplierModel}.  This parameter can also a be a
numeric \code{vector}, in which case the model will be replaced by an 'offset' constant with
values given in the vector}

\item{multiplierModel}{A \code{formula} object giving the relationship between the multiplier
and a set of covariates.  The left-hand term of the formula should be the term representing
GPP.  This parameter can also a be a numeric \code{vector}, in which case the model will be
replaced by an 'offset' constant with values given in the vector.  The default value for this
parameter is \code{1} which effectively removes this component from the modelling framework}

\item{indirectComponents}{A \code{list} object containing a series of model specifications
representing each of the indirect model components between the covariates.  Each element in
the list should itself be a list containing the following named elements: modelForm, family,
priorSpecification, numTrials, and suffix.  These elements are described in more detail
below}

\item{regCoeffs}{A character scalar containing the text \code{"none"},
\code{"ridge"}, or \code{"lasso"}.  This determines the type of regularisation to use for the
regression coefficients in the model.  \code{"none"} (the default) results in wide normal priors
for the regression coefficients.  \code{"ridge"} results in normal priors for each of the
regression coefficients regulated by a shared precision parameter which itself has a wide
gamma hyperprior.  \code{"lasso"} results in Laplace priors for each of the regression
coefficients regulated by a shared rate parameter which itself has a wide gamma hyperprior}

\item{lightStandards}{A numeric vector containing values of PAR for which predictions are
going to be made.  Can be \code{NULL} if no standardisation is required}

\item{mcmcParams}{A list containing parameters regulating the Markov chain Monte Carlo
algorithm applied in NIMBLE.  This list needs the following named elements: numRuns, numChains,
numBurnIn, thinDensity, predictThinDensity}
}
\value{
A \code{list} object containing the following elements:
\itemize{
  \item{modelDefinition}{The NIMBLE code used in the model definition as would be the output
  of \code{\link[nimble]{nimbleCode}}}
  \item{compiledModel}{The compiled NIMBLE model object as would be produced by running
  \code{\link[nimble]{nimbleModel}} followed by \code{\link[nimble]{compileNimble}}}
  \item{compiledMCMC}{The compiled NIMBLE MCMC object as would be produced by running
  \code{\link[nimble]{buildMCMC}} followed by \code{\link[nimble]{compileNimble}}}
  \item{parameterSamples}{A \code{\link[coda]{mcmc.list}} object containing the samples from
  the MCMC analysis}
  \item{parameterSummary}{A \code{data.frame} containing summary statistics for each of the
  sampled parameters}
  \item{predictionSamples}{A \code{\link[coda]{mcmc.list}} object containing the samples of the
  mean predictions from the MCMC analysis}
  \item{predictionSummary}{A \code{data.frame} containing summary statistics for the mean
  predictions}
  \item{WAIC}{A scalar containing the Watanabe-Akaike information criterion for the model}
  \item{standardisedValues}{A \code{list} of \code{data.frame} objects with each element containing
  predictions for each of the PAR standard values contained in \code{lightStandards}}
  \item{DHARMaResiduals}{A \copde{list} of objects as created by \code{\link[DHARMa]{createDHARMa}} that contains
  an analysis of residuals of each of the model sub-components.  The first element is the DHARMa analysis for the
  overall GPP residuals.  Each element afterwards is a DHARMa analysis for each of the indirect models.}
  \item{parameterFigures}{A \code{list} of graphical objects containing violin plots for each of
  the parameters for the submodels (each in a seperate panel)}
  \item{standardSummary}{A \code{list} with a length equal to the number of light standards in the
  \code{lightStandards} parameter.  Each element is a \code{data.frame} including the summary information
  of the MCMC samples.  This element is absent if \code{lightStandards} is \code{NULL}}
  \item{indirectModelOutputs}{A \code{list} containing the outputs from \code{\link{glmNIMBLE}} for each of the
  indirect component models specified in \code{indirectComponents}}
}
}
\description{
Function to fit a calibration model of gross primary productivity (GPP) against
photosynthically active radiation (PAR).  The calibration model is hierarchical in nature
and the parameters of the calibration curve (the x-assymptote, y-assymptote, and general
multiplier) can be linear functions of various covariates.
}
\details{
Each element of \code{indirectComponents} is a list containing the following elements:
\itemize{
  \item{modelFormula}{A \code{formula} object describing the relationships between covariates}
  \item{errorFamily}{A \code{family} object descrinig the error family to use to model the indirect
  relationships between the covariates and the link function to apply}
  \item{regCoeffs}{A character scalar used to determine the prior specification.  This
  is applied in the same way as the \code{regCoeffs} input parameter}
  \item{modelSuffix}{A suffix to give to nodes in this sub-model.  This can be used to avoid name clashes
  in complex models with many indirect components}
  \item{mcmcParams}{A list containing the MCMC options}
}
See \code{\link{glmNIMBLE}} for more information on how these parameters are interpreted.

\code{mcmcParams} is a list containing the following elements:
\itemize{
  \item{numSamples}{The number of iterations to sample from the posterior distribution in each chain}
  \item{numChains}{The number of chains to simulate in the MCMC algorithm}
  \item{numBurnIn}{The number of samples to remove at the beginning of each chain}
  \item{thinDensity}{The thinning parameter to use for the model paramters}
  \item{predictThinDensity}{The thinning parameter to use for the model predictions}
}
If any of the elements are missing from the \code{mcmcParams} object then sensible defaults are supplied.
}
\seealso{
\code{\link[DHARMa]{createDHARMa}} \code{\link[nimble]{nimbleCode}}
\code{\link[nimble]{buildMCMC}}
}
\author{
Joseph D. Chipperfield, \email{joechip90@googlemail.com}
}
